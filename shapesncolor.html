<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Advanced Image Editor</title>
<style>
  @import url('https://fonts.cdnfonts.com/css/lucida-handwriting-std');
</style>
<style>
  @import url('https://fonts.cdnfonts.com/css/md-dasher');
</style>
<style>
  @import url('https://fonts.cdnfonts.com/css/public-pixel');
</style>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
<style type="text/css">

.modal {
    display:    none;
    position:   fixed;
    z-index:    1000;
    top:        0;
    left:       0;
    height:     100%;
    width:      100%;
    background: rgba( 255, 255, 255, .8 ) 
                url('http://i.stack.imgur.com/FhHRx.gif') 
                50% 50% 
                no-repeat;
}
body.loading {
    overflow: hidden;   
}

body.loading .modal {
    display: block;
}
body {
    background-image: url('https://seanmurphy.dev/photojs/assets/images/bg.png');
    background-size: cover;
    background-repeat: no-repeat;
    font-family: 'Lucida Handwriting Std', 'MD Dasher', sans-serif;
}

.container {
    background-color: rgba(255, 255, 255, 0.8); 
    padding: 20px;
}

.card {
    background-color: rgba(255, 255, 255, 0.9); 
    margin-bottom: 20px;
}

.jumbotron h1 {
    font-family: 'Public Pixel', sans-serif;
}

#histogramCanvas {
        display: block;
        margin: 0 auto; /* Center the histogram */
        width: 600px; /* Adjust width as needed */
        height: 400px; /* Adjust height as needed */
    }

    #valueCanvas {
        display: block;
        margin: justify; /* Add margin for spacing */
        width: 400px; /* Adjust width as needed */
        height: auto; /* Make it responsive */
    }

    #valueCanvas {
        font-size: 18px; /* Increase font size */
        font-weight: bold; /* Make the font bold */
    }
</style>
</head>
<body>
<div class="container">
    <div class="jumbotron">
        <h1>Photobel - Advanced Image Editor</h1> 
        <p>Advanced Image Editor Programming 5 -13  - Jeriebel B. Calunsag</p> 
    </div>
    <div class="row">
        <div class="col-sm">
            <div class="card">
                <div class="card-header">
                Original Image
                </div>
                <div class="card-block text-center">
                    <img id="imageOriginal" alt="Upload" class="card-img-top"/>
                </div>
                <div class="card-footer text-muted">
                    <input type="file" id="imageInput" name="file" />
                </div>
            </div>
        </div>
        <div class="col-sm">
            <div class="card">
                <div class="card-header">
                Result
                </div>
                <div class="card-block">
                    <canvas id="imageCanvas"></canvas>
                </div>
                <ul class="list-group list-group-flush">
                    <li class="list-group-item">
                        <button type="button" id="detectShapesButton" class="btn btn-primary">Detect Shapes</button>
                    </li>
                    <li class="list-group-item">
                        <button type="button" id="detectObjectButton" class="btn btn-success">Detect Object</button>
                        <button type="button" id="removeBackgroundButton" class="btn btn-danger">Remove Background</button>
                        <!-- Modify the "Show RGB Histogram" button -->
                        <button type="button" id="showRGBHistogramButton" class="btn btn-primary" onclick="showRGBHistogram()">Show RGB Histogram</button>
                         <!-- Add the reset button -->
                        <button type="button" id="resetButton" class="btn btn-secondary">Reset</button>
                    </li>
                </ul>
                <div class="row">
                    <div class="col-sm">
                        <label for="thresholdSlider">Background Removal Threshold:</label>
                        <input type="range" id="thresholdSlider" name="thresholdSlider" min="0" max="255" value="100">
                        <span id="thresholdValue">100</span>
                    </div>
                <div class="card-footer">
                    <a href="#" id="downloadButton" class="card-link">Download Image</a>
                </div>
            </div>
        </div>
    </div>


    <div class="row">
        <div class="col-sm">
            <label for="rotateInput">Rotate Image (degrees): </label>
            <input type="range" id="rotateInput" name="rotateInput" min="0" max="360" value="0">
            <span id="rotationValue">0</span>
        </div>
        <div class="col-sm">
            <label for="mirrorSelect">Mirror Image: </label>
            <select id="mirrorSelect" name="mirrorSelect">
                <option value="0">No mirror</option>
                <option value="1">Horizontal</option>
                <option value="2">Vertical</option>
            </select>
        </div>
    </div>

    <!-- HTML code -->
<div class="row">
    <div class="col-sm">
        <label for="translateXInput">Translate X:</label>
        <input type="number" id="translateXInput" name="translateXInput" value="0">
    </div>
    <div class="col-sm">
        <label for="translateYInput">Translate Y:</label>
        <input type="number" id="translateYInput" name="translateYInput" value="0">
    </div>
</div>
<div class="row">
    <div class="col-sm">
        <button type="button" id="applyTranslationButton" class="btn btn-primary">Apply Translation</button>
    </div>
</div>

    <div class="row">
        <div class="col-sm">
            <div id="shapeCount"></div>
        </div>
        <div class="col-sm">
            <div id="colorCount"></div>
        </div>
    </div>

    <!-- <h2>Centroid Display: </h2> -->    

    <div class="row">
        <div class="col-sm">
            <div id="centroidDisplay">
                <!-- Centroid information will be displayed here -->      
                <h2>Centroid Display: </h2>
                <p id="imageCentroid"></p>
                <p id="objectCentroid"></p>
            </div>
        </div>
    </div>
</div>

  <!-- HTML code <div id="iframe-container"></div> -->
  
  <div class="container">
    <h2 id="histogramTitle">RGB HISTOGRAM</h2>
    <!-- Existing HTML content -->
  <!-- Canvas for displaying the histogram -->
  <canvas id="histogramCanvas"></canvas>
  <!-- Canvas for displaying histogram values -->
  <canvas id="valueCanvas" width="200" height="80"></canvas>
</div>


<div class="modal"></div>
<script type="text/javascript">
    document.body.classList.add("loading");

    
    // Function to receive edited image data and display in the result canvas
    window.addEventListener('message', function(event) {
        var imageData = event.data;
        var canvas = document.getElementById('imageCanvas');
        var ctx = canvas.getContext('2d');
        var img = new Image();
        img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
        };
        img.src = imageData;
    });


    let imgElement = document.getElementById('imageOriginal');
    let inputElement = document.getElementById('imageInput');
    inputElement.addEventListener('change', (e) => {
        // Clear display labels
        document.getElementById('imageCentroid').innerText = "";
        document.getElementById('objectCentroid').innerText = "";
        document.getElementById('shapeCount').innerHTML = "";
        document.getElementById('colorCount').innerHTML = "";
        imgElement.src = URL.createObjectURL(e.target.files[0]);
    }, false);
    let mat;
    
    imgElement.onload = function() {
      mat = cv.imread(imgElement);
      cv.imshow('imageCanvas', mat);
    };
    
    let shapeCount;
    let colorCounts;
    
    window.addEventListener('message', function(event) {
        var imageData = event.data;
        var imgElement = document.getElementById('imageOriginal');
        imgElement.src = imageData;
    });

    document.getElementById('detectShapesButton').onclick = async function() {
        this.disabled = true;

        shapeCount = {
            "Circle": 0,
            "Triangle": 0,
            "Square": 0,
            "Rectangle": 0,
            "Quadrilateral": 0,
            "Pentagon": 0
        };

        colorCounts = {
            'yellow': 0,
            'red': 0,
            'blue': 0,
            'green': 0
        };

        let src = cv.imread('imageCanvas');
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

        cv.adaptiveThreshold(gray, gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

        let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
        cv.dilate(gray, gray, kernel);
        cv.erode(gray, gray, kernel);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let dst = src.clone();
        let colors = [new cv.Scalar(57, 255, 20, 255)];

        let imageCentroid = { x: 0, y: 0 };
        let objectCentroid = { x: 0, y: 0 };

        for (let i = 0; i < contours.size(); ++i) {
            let contour = contours.get(i);
            let perimeter = cv.arcLength(contour, true);
            let epsilon = 0.03 * perimeter; 
            let approx = new cv.Mat();
            cv.approxPolyDP(contour, approx, epsilon, true);

            let numVertices = approx.rows;

            let shape;
            if (numVertices === 3) {
                shape = "Triangle";
            } else if (numVertices === 4) {
                let { width, height } = cv.boundingRect(approx);
                let aspectRatio = width / height;
                let area = cv.contourArea(approx);
                if (Math.abs(aspectRatio - 1) < 0.2) {
                    shape = "Square";
                    shapeCount["Quadrilateral"]++; 
                } else if (aspectRatio > 1.2 && aspectRatio < 2.3) {
                    shape = "Rectangle";
                    shapeCount["Quadrilateral"]++; 
                } else {
                    shape = "Quadrilateral";
                }
            } else if (numVertices === 5) {
                shape = "Pentagon";
            } else {
                shape = "Circle";
            }

            shapeCount[shape]++;

            let moments = cv.moments(contour, false);
            let x = moments.m10 / moments.m00;
            let y = moments.m01 / moments.m00;
            let center = new cv.Point(x, y);

            imageCentroid.x += x;
            imageCentroid.y += y;

            cv.drawContours(dst, contours, i, colors[0], 2, cv.LINE_8, hierarchy, 0);
            cv.putText(dst, shape, center, cv.FONT_HERSHEY_SIMPLEX, 0.5, new cv.Scalar(57, 255, 20, 255), 2);
            contour.delete();
            approx.delete();

            let colorText = getColorText(src, x, y);
            cv.putText(dst, colorText, new cv.Point(x, y - 20), cv.FONT_HERSHEY_SIMPLEX, 0.5, new cv.Scalar(57, 255, 20, 255), 2);
            colorCounts[colorText.toLowerCase()]++;

            objectCentroid.x = x;
            objectCentroid.y = y;
        }

        imageCentroid.x /= contours.size();
        imageCentroid.y /= contours.size();

        cv.circle(dst, new cv.Point(imageCentroid.x, imageCentroid.y), 5, new cv.Scalar(0, 255, 0, 255), cv.FILLED);
        cv.circle(dst, new cv.Point(objectCentroid.x, objectCentroid.y), 5, new cv.Scalar(255, 0, 0, 255), cv.FILLED);

        document.getElementById('imageCentroid').innerText = `Image Centroid: (${imageCentroid.x.toFixed(2)}, ${imageCentroid.y.toFixed(2)})`;
        document.getElementById('objectCentroid').innerText = `Object Centroid: (${objectCentroid.x.toFixed(2)}, ${objectCentroid.y.toFixed(2)})`;

        cv.imshow('imageCanvas', dst);
        src.delete();
        gray.delete();
        hierarchy.delete();
        contours.delete();
        dst.delete();

        updateCounts();

        this.disabled = false;
    };
  
    document.getElementById('detectObjectButton').onclick = async function() {
    // Read the source image from the canvas
    let src = cv.imread('imageCanvas');
    
    // Convert the image to grayscale
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

    // Apply adaptive thresholding to segment the object
    cv.adaptiveThreshold(gray, gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

    // Apply morphological operations to clean up the binary image
    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
    cv.dilate(gray, gray, kernel);
    cv.erode(gray, gray, kernel);

    // Find contours in the binary image
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // Clone the source image to draw the markings
    let dst = src.clone();
    let colors = [new cv.Scalar(0, 255, 0, 255)]; // Green color for bounding boxes

    // Variables to store object area and centroid
    let objectArea = 0;
    let objectCentroidX = 0;
    let objectCentroidY = 0;

    // Initialize image centroid object
    let imageCentroid = { x: 0, y: 0 };

    // Iterate through each contour
    for (let i = 0; i < contours.size(); ++i) {
        let contour = contours.get(i);
        let rect = cv.boundingRect(contour);
        let point1 = new cv.Point(rect.x, rect.y);
        let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);

        // Draw bounding box around the contour
        cv.rectangle(dst, point1, point2, colors[0], 2);

        // Calculate object area
        let area = cv.contourArea(contour);
        objectArea += area;

        // Calculate object centroid
        let moments = cv.moments(contour, false);
        let cx = moments.m10 / moments.m00;
        let cy = moments.m01 / moments.m00;

        // Draw a cross marking at the centroid
        let size = 5;
        cv.line(dst, new cv.Point(cx - size, cy), new cv.Point(cx + size, cy), colors[0], 2);
        cv.line(dst, new cv.Point(cx, cy - size), new cv.Point(cx, cy + size), colors[0], 2);

        // Sum up centroid coordinates
        objectCentroidX += cx;
        objectCentroidY += cy;

        // Sum up image centroid coordinates
        imageCentroid.x += cx;
        imageCentroid.y += cy;

        // Release resources
        contour.delete();
    }

    // Display the result image on the canvas
    cv.imshow('imageCanvas', dst);

    // Display object area and centroid directly below the image
    if (contours.size() > 0) {
        let centroidDisplay = document.getElementById('centroidDisplay');

        // Calculate average centroid coordinates
        objectCentroidX /= contours.size();
        objectCentroidY /= contours.size();

        let objectAreaDisplay = document.createElement('p');
        objectAreaDisplay.innerText = 'Object Area: ' + objectArea.toFixed(2);
        centroidDisplay.appendChild(objectAreaDisplay);

        let objectCentroidDisplay = document.createElement('p');
        objectCentroidDisplay.innerText = 'Object Centroid: (' + objectCentroidX.toFixed(2) + ', ' + objectCentroidY.toFixed(2) + ')';
        centroidDisplay.appendChild(objectCentroidDisplay);

        // Calculate average image centroid coordinates
        imageCentroid.x /= contours.size();
        imageCentroid.y /= contours.size();

        // Add labels for Image Centroid and Object Centroid
        document.getElementById('imageCentroid').innerText = `Image Centroid: (${imageCentroid.x.toFixed(2)}, ${imageCentroid.y.toFixed(2)})`;
        
        // Add label for Image Area
        let imageAreaDisplay = document.createElement('p');
        imageAreaDisplay.innerText = 'Image Area: ' + src.cols * src.rows;
        centroidDisplay.appendChild(imageAreaDisplay);
    }

    // Release resources
    src.delete();
    gray.delete();
    hierarchy.delete();
    contours.delete();
    dst.delete();
};

// Event listener for rotation input
document.getElementById('rotateInput').addEventListener('input', (e) => {
    let degree = parseInt(e.target.value);
    rotationDegree = degree;
    rotateImage(rotationDegree);
    // Update rotation value display
    document.getElementById('rotationValue').innerText = degree;
});

// Event listener for background removal threshold slider
document.getElementById('thresholdSlider').addEventListener('input', (e) => {
    let threshold = parseInt(e.target.value);
    removeBackground(mat, threshold);
    // Update threshold value display
    document.getElementById('thresholdValue').innerText = threshold;
});


let rotationDegree = 0;
let flipMode = 0; // 0: No flip, 1: Horizontal flip, 2: Vertical flip

// Function to rotate the image
function rotateImage(degree) {
    let rotatedMat = new cv.Mat();
    let center = new cv.Point(mat.cols / 2, mat.rows / 2);
    let M = cv.getRotationMatrix2D(center, degree, 1);
    cv.warpAffine(mat, rotatedMat, M, mat.size(), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

    cv.imshow('imageCanvas', rotatedMat);
}

// Function to flip the image
function flipImage(flipMode) {
    let flippedMat = new cv.Mat();
    cv.flip(mat, flippedMat, flipMode);

    cv.imshow('imageCanvas', flippedMat);
    mat.delete();
    mat = flippedMat;
}

// Event listener for rotation input
document.getElementById('rotateInput').addEventListener('input', (e) => {
    let degree = parseInt(e.target.value);
    rotationDegree = degree;
    rotateImage(rotationDegree);
});

// Event listener for mirror selection
document.getElementById('mirrorSelect').addEventListener('change', (e) => {
    let mode = parseInt(e.target.value);
    flipMode = mode;
    flipImage(flipMode);
});

// JavaScript code

// Event listener for translation button
document.getElementById('applyTranslationButton').addEventListener('click', () => {
    let translateX = parseInt(document.getElementById('translateXInput').value);
    let translateY = parseInt(document.getElementById('translateYInput').value);

    translateImage(translateX, translateY);
});

// Function to translate the image
function translateImage(translateX, translateY) {
    let translatedMat = new cv.Mat();
    let M = cv.matFromArray(2, 3, cv.CV_64FC1, [1, 0, translateX, 0, 1, translateY]);
    cv.warpAffine(mat, translatedMat, M, mat.size(), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

    cv.imshow('imageCanvas', translatedMat);
    mat.delete();
    mat = translatedMat;
}


    function updateCounts() {
        let shapeCountDiv = document.getElementById('shapeCount');
        shapeCountDiv.innerHTML = "<h2>Shape Count:</h2>";
        for (let shape in shapeCount) {
            shapeCountDiv.innerHTML += "<p>" + shape + ": " + shapeCount[shape] + "</p>";
        }

        let colorCountDiv = document.getElementById('colorCount');
        colorCountDiv.innerHTML = "<h2>Color Count:</h2><ul>";
        for (let color in colorCounts) {
            colorCountDiv.innerHTML += '<li>' + color + ': ' + colorCounts[color] + '</li>';
        }
        colorCountDiv.innerHTML += '</ul>';
    }

    function getColorText(src, x, y) {
        let hsv = new cv.Mat();
        cv.cvtColor(src, hsv, cv.COLOR_RGB2HSV);
        
        let pixel = hsv.ucharPtr(y, x);
        let h = pixel[0];
        let s = pixel[1];
        let v = pixel[2];
        
        let color;
        if ((h >= 20 && h <= 40) && (s >= 50 && s <= 255) && (v >= 50 && v <= 255)) {
            color = "Yellow";
        } else if ((h >= 0 && h <= 10 || h >= 160 && h <= 180) && (s >= 50 && s <= 255) && (v >= 50 && v <= 255)) {
            color = "Red";
        } else if ((h >= 90 && h <= 130) && (s >= 50 && s <= 255) && (v >= 50 && v <= 255)) {
            color = "Blue";
        } else if ((h >= 40 && h <= 80) && (s >= 50 && s <= 255) && (v >= 50 && v <= 255)) {
            color = "Green";
        } else {
            color = "Unknown";
        }

        hsv.delete();

        return color;
    }

    document.getElementById('downloadButton').onclick = function() {
        this.href = document.getElementById("imageCanvas").toDataURL();
        this.download = "image.png";
    };

    // Function to remove background
    function removeBackground(mat, threshold) {
        // Convert the image to grayscale
        let gray = new cv.Mat();
        cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);

        // Threshold the image to create a binary mask for background
        let binary = new cv.Mat();
        cv.threshold(gray, binary, threshold, 255, cv.THRESH_BINARY);

        // Find contours of the binary mask
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // Create a black filled mask
        let mask = cv.Mat.zeros(mat.rows, mat.cols, cv.CV_8UC1);

        // Draw contours on the mask (in white)
        let color = new cv.Scalar(255, 255, 255, 255); // White color
        cv.drawContours(mask, contours, -1, color, -1, 8, hierarchy, 2);

        // Apply the mask to the original image to remove background
        let result = new cv.Mat();
        cv.bitwise_and(mat, mat, result, mask);

        // Display the result
        cv.imshow('imageCanvas', result);

        // Clean up
        gray.delete();
        binary.delete();
        contours.delete();
        hierarchy.delete();
        mask.delete();
        result.delete();
    }

    document.getElementById('removeBackgroundButton').onclick = function() {
        // Get the background removal threshold from the slider
        let threshold = parseInt(document.getElementById('thresholdSlider').value);

        removeBackground(mat, threshold);
    };

     /** 
    @module histogram
    */
    "use strict";
    function Histogram(conf){
        if (!(this instanceof Histogram)) return new Histogram(conf);

        this.histogram = [];
        this.conf = {
            width: 255,
            height: 128,
            red: "#d55",
            green: "#5d5",
            blue: "#55d",
            black: "#555"
        };
        this.setConf(conf);
        this.canvas = document.getElementById('histogramCanvas');
        this.context = this.canvas.getContext('2d');
        this.valueCanvas = document.getElementById('valueCanvas');
        this.valueContext = this.valueCanvas.getContext('2d');
        this.clearRGB();
    }

    Histogram.prototype.setConf = function(conf){
        var name = "";
        for (name in conf){
            this.conf[name] = conf[name];
        }
        return this;
    };

    Histogram.prototype.forImg = function(source){
        var srcCanvas = document.createElement("canvas");
        var ctx = srcCanvas.getContext('2d');
        ctx.canvas.width = source.width;
        ctx.canvas.height = source.height;
        ctx.drawImage(source, 0, 0);
        return this.forCanvas(srcCanvas);
    };

    Histogram.prototype.forCanvas = function(source){
        var ctx = source.getContext('2d');
        var img = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        for (var i=0; i<img.data.length; i=i+4){
            this.setRGB({
                r: img.data[i],
                g: img.data[i+1],
                b: img.data[i+2]
            });
        }

        return this.draw();
    };

    Histogram.prototype.clearRGB = function(){
        for (var i=0; i<=255; i++){
            this.histogram[i] = {
                r: 0,
                g: 0,
                b: 0
            };
        }
    };

    Histogram.prototype.setRGB = function(val){
        this.histogram[Math.min(255, Math.max(0, val.r))].r++;
        this.histogram[Math.min(255, Math.max(0, val.g))].g++;
        this.histogram[Math.min(255, Math.max(0, val.b))].b++;
    };

    Histogram.prototype.draw = function(){
        this.context.canvas.width = this.conf.width;
        this.context.canvas.height = this.conf.height;	
        
        var m=0;
        for (var i = 1; i < 255; i++){
            m = Math.max(m, this.histogram[i].r, this.histogram[i].g, this.histogram[i].b);
        }
        
        this.context.globalCompositeOperation="lighter";

        this.drawPoly(this.conf.red, function(val){
            return val.r / m;
        });

        this.drawPoly(this.conf.green, function(val){
            return val.g / m;
        });

        this.drawPoly(this.conf.blue, function(val){
            return val.b / m;
        });

        this.context.globalCompositeOperation="source-over";	

        this.drawPoly(this.conf.black, function(val){
            var r = val.r / m;
            var g = val.g / m;
            var b = val.b / m;
            return Math.min(r,g,b);					
        });

        // Clear the value canvas
        this.valueContext.clearRect(0, 0, this.valueCanvas.width, this.valueCanvas.height);
        
        // Draw values
        this.valueContext.font = "14px Arial, sans-serif";
        this.valueContext.fillStyle = '#000';
        this.valueContext.fillText("Red: " + Math.round(this.histogram[255].r * 100 / m) / 100, 10, 20);
        this.valueContext.fillText("Green: " + Math.round(this.histogram[255].g * 100 / m) / 100, 10, 40);
        this.valueContext.fillText("Blue: " + Math.round(this.histogram[255].b * 100 / m) / 100, 10, 60);
        this.valueContext.fillText("Black: " + Math.round(Math.min(this.histogram[255].r, this.histogram[255].g, this.histogram[255].b) * 100 / m) / 100, 10, 80);

        return this.canvas.toDataURL();
    };

    Histogram.prototype.drawPoly = function(colour, val){
    var w = this.context.canvas.width;
    var h = this.context.canvas.height;
    var barWidth = w / 255; // Adjust the width of each bar

    this.context.beginPath();        
    this.context.moveTo(0, h);        
    this.context.fillStyle = colour;
    
    for (var x = 0; x <= 255; x++){
        // Calculate the X-coordinate of the bar start point
        var xStart = x * barWidth;
        // Calculate the X-coordinate of the bar end point
        var xEnd = (x + 1) * barWidth;
        // Adjust the height of the bar based on the histogram value
        var barHeight = h - (val(this.histogram[x]) * h);
        
        // Draw the bar
        this.context.lineTo(xStart, barHeight);
        this.context.lineTo(xEnd, barHeight);
    }           
    
    this.context.lineTo(w, h);
    this.context.closePath();
    this.context.fill();
};



    // Function to show RGB histogram
function showRGBHistogram() {
    // Access the original image element
    var imgElement = document.getElementById('imageOriginal');

    // Check if the image is loaded
    if (imgElement.src !== '') {
        // Create a new histogram instance
        var histogram = new Histogram();

        // Draw the histogram for the original image
        histogram.forImg(imgElement);
    } else {
        // Alert if no image is selected
        alert("Please select an image first.");
    }
}


    document.getElementById('resetButton').addEventListener('click', function() {
    // Reload the original image onto the canvas
    var originalImage = document.getElementById('imageOriginal');
    var canvas = document.getElementById('imageCanvas');
    var ctx = canvas.getContext('2d');
    ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
});


    function onOpenCvReady() {
        document.body.classList.remove("loading");
    }
</script>
<script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
<!-- Include external HTML <div id="iframe-container">
    <iframe src="rgbhistogram.html" frameborder="0" width="100%" height="600"></iframe> -->
</div>
</body>
</html>
